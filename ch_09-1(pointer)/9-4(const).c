#include <stdio.h>
int main(void)
{
    int a = 10, b = 20;

    const int *pa = &a;               // pa -> a
    printf("변수 a의 값: %d\n", *pa); // 포인터를 간접 참조하여 a 출력

    pa = &b;                          // pa -> b . b의 주소값 할당
    printf("변수 b의 값: %d\n", *pa); // 포인터를 간접 참조하여 b 출력

    pa = &a; // 다시 pa -> a

    // *pa = 20;   포인터에 const를 사용했기 때문에 이렇게 간접참조 하여 값을 바꿀 수는 없다.

    a = 20; // a를 직접 참조하여 값을 변경

    printf("변수 a값 : %d\n", *pa); // 포인터로 간접 참조하여 바뀐값 출력

    return 0;
}
/*
결과:
변수 a의 값: 10
변수 b의 값: 20
변수 a값 : 20


#   포인터에 사용되는 const
:
const 예약어를 사용하면 이를 가리키는 변수의 값을 바꿀 수 없다는 의미이다. 변수에 사용할 때와는 의미가 다르다.

위 코드에서는  포인터 pa를 선언할 때 const로 상수화 했다. cosnt가 일반 변수처럼 포인터 값을 고정시킨다면
pa = &b; 에서 pa는 b의 주소값을 저장할 수 없었을 것이다.
그러나 출력 결과에서는 pa는 const의 사용과느 무관하게 b의 주소를 저장하고 그 값을 간접참조하여 출력하고 있다.

그렇다면 포인터에 사용된 const의 의미는 무엇일까?
바로 pa가 가리키는 변수 a는, pa를 간접 참조(*)하여 바꿀 수 없다는 것이다.


#   포인터에 const를 사용하는 이유
:
포인터에 const를 사용한느 대표적인 예는 문자열 상수를 인수로 받는 함수이다.
문자열 상수는 값이 바뀌면 안 되는 저장공간이므로 함수의 매개변수를 통해 값을 바꿀 수 없도록
매개변수로 선언된 포인터에 const를 사용한다.
*/