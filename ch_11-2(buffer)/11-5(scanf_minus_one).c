#include <stdio.h>

int main(void)
{
    int res; // scanf 함수의 반환값을 저장할 변수
    char ch; // 문자를 입력할 변수

    while (1)
    {
        res = scanf("%c", &ch); // 문자 입력, <ctrl> + <Z>를 누르면 -1 반환
        if (res == -1)
            break;         // 반환값이 -1이면 반복 종료
        printf("%d ", ch); // 입력된 문자의 아스키 코드 값 출력
    }

    return 0;
}

/*
A
65 10 cat
99 97 116 10 ^Z
^Z


*/

/*
scanf 함수 반환값 활용
:
프로그램 사용자가 키보드로 한 줄을 입력할 때 입력을 끝내려면 엔터를 누르면 된다.
그런데 개행 문자 또한 하나의 입력데이터로 쓴다면 입력을 종료하는 별도의 신호가 필요하다.
이 때 scanf 함수의 반환값을 사용한다.

윈도우 운영체제에서는 scanf 함수는 키보드로 ctrl + z를 누르면 -1을 반환한다.
(ctrl + z을 누르고 엔터를 누른 뒤에 ctrl + z를 한 번 더 눌러야 할 수도 있음.)
유닉스/리눅스 환경에서는 ctrl + d를 누르면 -1을 반환한다.

결국 scanf 함수가 -1을 반환하기 전까지 반복 입력하면 개행문자를 포함하나 모든 문자를 데이터로 사용할 수 있다.


위 코드에서, 엔터를 누르는 순간 입력한 값이 버퍼로 저장되고 반복문이 수행되면서 버퍼의 문자를
하나씩 가져다 아스키 코드 값을 출력한다. 버퍼의 데이터를 모두 처리하면 다시 키보드로부터
새로운 데이터를 입력받기 위해 대기 상태가 된다.
마지막으로 ctrl +z를 누르면 scanf 함수는 -1을 반환하고 if문의 조건식이 참이 되어 반복 종료된다.
참고로 엔터(개행문자)의 아스키코드는 10이다. 그리고 버퍼 값이 scanf로 넘어가면서 버퍼는 비워진다.

키보드로 숫자를 입력하는 경우에도 일단 문자열의 형태로 버퍼에 저장된다. 그 후에 문자열이 실제 연산이 가능한
값으로 변환되어 변수에 저장된다. 예를 들어 int형 변수 a에 20을 입력하는 경우, 문자 '2'와 '0'이 각각
아스키 코드 값으로 코드화 되어 버퍼에 저장된다. 그 후에 변환 문자의 지시에 따라 연산이 가능한 숫자로 변환되어
변수에 저장된다.

- 20\n 입력
- 각 문자가 코드화 되어 저장 [00110010][00110000][00001010]
- 변수 a에는 연산이 가능한 2진수의 비트열로 저장 [00000000 00000000 00000000 00010100]

결국 변환 문자는 코드화된 문자열을 숫자로 변환하는 방법은 scanf 함수에 알려주는 역할을 한다.
같은 입력에 대해 %lf 변환 문자를 쓰고 실수형 변수에 입력한다면 버퍼에 저장된 상태는
같지만 IEEE754 표준에 따라 변환되므로 변수에 저장되는 비트열의 크기와 형태는 달라진다.

#   scanf 함수의 반환값과 비교하는 EOF
:
scanf 함수의 반환값과 비교하는 값으로 -1 대신 EOF를 쓸 수 있다.
stdio.h 헤더 파일에는 소스 코드에 있는 EOF라는 이름을 -1로 바꾸는 전처리 지시자가 있다.
따라서 아래와 같이 작성도 가능한다.

res = scanf("%c", &ch);
if(res = EOF) break;    //  EOF는 -1로 바뀌므로 결국 res와 -1을 비교한다.

*/