#include <stdio.h>
int main(void)
{
    int a = 10; // 1010
    int b = 12; // 1100

    printf("a & b : %d\n", a & b); // 1000
    printf("a ^ b : %d\n", a ^ b); // 110
    printf("a | b : %d\n", a | b); // 1110

    printf("~a : %d\n", ~a); // ~10 = 1111 1111 1111 1111 1111 1111 1111 0101 = -11

    printf("a << 1 : %d\n", a << 1); // 전체 비트 왼쪽으로 하나씩 이동. 10*2 = 20
    printf("a >> 2 : %d\n", a >> 2);
    // a값이 양수이고 부호비트가 0이므로 부호비트 0으로 채워짐. 음수라면 왼쪽 자리가 1로 채워짐.
    // 비트 이동 연산을 수행해도 부호는 변하지 않는다. 단 unsigned로 선언되었다면 부호비트가 무의미하므로 항상 0으로 채워진다.
    // 여기서는 두 번 이동했으므로 10/4 = 2이다.

    printf("%d\n", a); // 10

    return 0;
}

/*
비트 연산자는 데이터를 비트 단위로 연산한다.
비트 연산자에는 논리 연산을 수행하는 논리연산자와,
비트들을 좌우로 움직이는 비트 이동 연산자가 있다.

논리 연산자: &, |, ^
비트 이동 연산자: >>, <<

비트 연산자는 데이터를 비트로 정확히 표현할 수 있는 "정수"에만 사용할 수 있다.


& : 비트 단위의 논리곱'AND' 연산은 두 입력 비트가 모두 1일 때만 1을 반환.
^ : 비트 단위의 '배타적; 논리합 연산은 두 피연산자의 진리값이 서로 다를 때에만 참이다. 즉 1이다.
| : 비트 단위의 논리합 'OR' 연산은 두 비트 중에서 하나라도 1(참)이면 1로 1(참)로 계산한다.
~ : 비트 단위의 부정 연산자는 피연산자가 하나이며 피연산자의 비트를 반전시킨다.

<<: 피연산자의 비트들을 모두 왼쪽으로 한 비트씩 이동시킨다. 이 때 왼쪽으로 밀려나는 비트는 사라지고
    오른쪽의 남는 비트는 0으로 채워진다. 왼쪽으로 한 비트씩 이동할 때마다 값에 2가 곱해진다.

>>: 피연산자의 비트들을 모두 오른쪽으로 한 비트씩 이동시킨다.
    이 때 오른쪽으로 밀려나는 비트는 사라지고 왼쪽의 남는 비트는 부호비트로 채워진다.
    값을 2로 나눈 '몫'이 된다.


비트 연산자는 대입 연산자와 함께 사용할 수 있다.

a=a<<2; 는 a<<=2;와 같다. &=,^=, |=, <<=, >>= 총 다섯 개의 복합 대입 연산자를 사용할 수 있다.

*/