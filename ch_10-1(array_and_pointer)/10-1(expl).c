#include <stdio.h>
int main(void)
{
    int ary[3];
    int i;

    *(ary + 0) = 10;              // ary[0] = 10;   //100번부터 시작한다고 했을 때, 100 + 0 == 100 + (0*sizeof(int)) == *100 = 10
    *(ary + 1) = *(ary + 0) + 10; // ary[1] = ary[0] + 10;  //100 + 1 = 100 + (1*sizeof(int)) == *104 = 10+10

    printf("세 번째 배열 요소에 키보드 입력: ");
    scanf("%d", ary + 2); //&ary[2] 어차피 주소값이므로 &를 쓸 필요가 없다. 게다가 &연산이 제외된다. 그러나 가독성이 향상된다/

    for (i = 0; i < 3; i++)
    {
        printf("%5d", *(ary + i)); // ary[i]
    }

    return 0;
}
/*
세 번째 배열 요소에 키보드 입력: 30
   10   20   30
*/

/*
배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다. 따라서 각 배열 요소는 일정한 간격으로 주소를 갖게 된다.
int ary[5];의 배열이 메모리 100번지부터 할당되고, int형 변수의 크기가 4바이트라면 각 배열 요소의 주소는
100, 104, 108, 112, 116이 된다.

결국 첫 번째 요소의 주소를 알면 나머지 요소의 주소도 쉽게 알 수 있고 각 주소에 간접 참조 연산을 수행하면
모든 배열 요소를 사용할 수 있다.

따라서 컴파일러는 첫 번째 배열 요소의 주소를 쉽게 사용하도록,
배열명을 컴파일 과정에서 첫 번째 배열 요소의 주소로 변경한다.

즉 ary = &ary[0]이고, *ary 또는 *(ary + 0)은 첫 번째 배열 요소의 값을 의미한다.

주의할 점은, 배열명은 첫 번째 요소의 주소를 나타내지만, 상수 포인터이므로 그 값을 다른 주소로 변경할 수는 없다.
즉, ary = &ary[1];과 같은 코드는 컴파일 에러를 발생시킨다.


#   배열명으로 배열 요소 사용하기.
:
주소는 정수처럼 보이지만 자료형에 대한 정보를 갖고 있는 특별한 값이다. 따라서 연산을 자유롭게 할 수 없다.
정해진 연산만 가능하다. 정수 덧셈의 경우 아래와 같은 방식으로만 수행된다.

주소 + 정수 ==> 주소 + (정수 * 주소를 구한 변수의 크기)

크기가 4바이트인 int형 변수 a의 주소 100번지에 1을 더한 결과는 104이다.
&a + 1 ==> 100 + (1 * sizeof(int)) = 104


#   배열의 할당 영역을 벗어나는 포인터 연산식
:
ary + 3에도 사용 가능하지만, 거기에 어떤 값이 저장돼 있는지 모르므로 오류발생 가능성이 있다.



*/