#include <stdio.h>

int main(void)
{
    printf("apple이 저장된 시작 주소 값 : %p\n", "apple");   // 주소 값 출력
    printf("두 번째 문자의 주소 값 : %p\n", "apple" + 1);    // 주소 값 출력
    printf("첫 번째 문자 : %c\n", *"apple");                 // 간접 참조 연산. apple에는 char 배열의 시작요소인 a의 주소값이 저장된다.
    printf("배열로 표현한 세 번째 문자 : %c\n", "apple"[2]); // 배열 표현식

    return 0;
}

/*
apple이 저장된 시작 주소 값 : 00007FF6D41B4000
두 번째 문자의 주소 값 : 00007FF6D41B4001
첫 번째 문자 : a
배열로 표현한 세 번째 문자 : p

printf함수에서 %p로 출력하면 그 값을 16진수로 확인할 수 있다. p는 주로 포인터를 출력하라 때 사용하는 변환문자이며,
포인터 값을 16진수 대문자로 출력한다.
*/

/*
컴파일 과정에서 문자열은 첫 번째 문자의 주소로 둔갑하고 그 이후는 배열을 출력하는 것과 같은 과정을 거친다.

#   문자열 상수 구현방법
: 문자열은 크기가 일정하지 않다. 컴파일러는 컴파일 과정에서 문자열을 char 배열 형태로 따로 보관하고
문자열 상수가 있던 곳에는 배열의 위치 값을 사용한다.
문자열 "apple"은 문자 'a'가 저장된 메모리의 주소 값으로 바뀐다.

결국 문자열은 컴파일 과정에서 char 변수의 주소로 바뀌므로 직접 포인터 연산을 수행할 수 있다.
"apple" + 1 처럼 정수를 더하면 다음 문자의 주소를 구할 수 있고 *"apple" 처럼 간접 참조 연산을 수행하면
첫 번째 문자가 된다. "apple"[2]처럼 배열명처럼 사용하는 것도 가능하다.

* 주의
:
주소로 접근하여 문자열을 바꿔서는 안 된다. *"apple" = t; 와 같이 간접 참조 연산을 통해 값을 대입하려는 시도는 위험하다.
연산 자체는 문제가 없고 정상 컴파일 되지만 운영체제에 의해 강제 종료될 가능성이 있다. 운영체제는 문자열 상수를
"읽기 전용" 메모리 영역에 저장한다. 따라서 그 값을 바꾸는 명령의 실행을 제외한다.

문자열을 주소(char배열 첫 번째 요소의 주소)로 바꾸면 포인터 연산을 통해 문자열의 시작 위치부터 길이 제한 없이 사용할 수 있다.
이 경우 문자열의 끝을 알아야 하므로 문자열의 끝을 표시하기 위해 null 문자를 사용한다. 따라서 컴파일러는 문자열 상수를 따로
저장할 때 마지막에 항상 null 문자를 붙여준다.

*/