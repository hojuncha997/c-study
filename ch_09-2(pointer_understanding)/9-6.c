#include <stdio.h>
int main(void)
{
    int a = 10;  // 변수 선언과 초기화
    int *p = &a; // 포인터 선언과 초기화
    double *pd;  // double형 변수를 가리키는 포인터

    pd = p; // 포인터 p 값을 포인터 pd에 대입. 즉, 변수a의 시작 주소값을 double형 포인터에 입력.
    printf("%lf\n", pd);

    return 0;
}

/*
#포인터의 대입 규칙
:
    규칙1: 포인터는 가리키는 변수의 형태가 같을 때만 대입해야 한다.
    규칙2: 형 변환을 사용한 포인터의 대입은 언제나 가능하다.

*/

/*
결과:
error: cannot convert 'int*' to 'double*' in assignment
    8 |     pd = p; // 포인터 p 값을 포인터 pd에 대입. 즉, 변수a의 시작 주소값을 double형 포인터에 입력.
      |          ^
      |          |
      |          int*


규칙1: 포인터는 가리키는 변수의 형태가 같을 때만 대입해야 한다.

컴파일러는 p에 저장된 값을 int형 변수의 주소로 생각한다. pd에 저장된 값은 double형 변수의 주소로 생각한다.
따라서 pd에 p를 대입한 후 간접참조 연산을 수행하면 변수 a에 할당된 영역 이후 할당되지 않은 영역까지 사용하게 된다.
(책에서는 옳지 못한 값이 출력되었다. 내 실습환경에서는 위와 같은  에러가 출력되며 컴파일 실패하였다.)

변수 a가 100번지부터 할당되었다고 할 때, pd를 통해 간접 참조 연산을 수행하면 메모리 107번지까지 8바이트를 하나의 double형 변수로 생각하고
그 안에 있는 실수 값으로부터 해석하므로 알수 없는 값이 출력된다. 특히 104번부터 107번까지가 다른 변수에 이미 할당돼 있는 경우,
*pd를 대입 연산자 왼쪽에 사용하면 그 변수의 값이 바뀌게 된다.



규칙2: 형 변환을 사용한 포인터의 대입은 언제나 가능하다.
    포인터가 가리키는 자료형이 다른 경우라도 형 변환 연산자를 사용하면 경고 메시지 없이 대입할 수 있다.
물론 대입한 후 포인터를 통한 사용에 문제가 없어야 한다.

double a = 3.4;
double *pd = &a;
int *pi;
pi = (int *)pd;

여기서 pi에 간접 참조 연산을 수행하면 변수 a의 일부를 int형 변수처럼 사용할 수 있다.
이런 방법은 포인터로 메모리를 직접 쪼개 쓰는 것이므로 데이터가 메모리에 저장되는 방식을 충분히 이해하고 있어야 한다.
만약 *pi = 10;과 같이 a의 일부분에 정수를 저장하면 정수와 실수의 데이터 크기와 저장방식이 다르므로 a에 저장한 실수 값은 사용할 수 없다.


#   포인터에 번지를 직접 대입할 수도 있다.
int *p;
p = (int *) 100;
*p = 10
그러나 기존 메모리 100~103이 어떤 용도로 사용되고 있는지 알 수 없으므로,
항상 정상적으로 할당 받은 주소를 저장해서 사용해야 한다. 같은 이유로 초기화 하지 않은 포인터를 간접참조연산하는 것은 더욱 위험하다.
알 수 없는 곳의 데이터를 바꿔버린다.






*/
