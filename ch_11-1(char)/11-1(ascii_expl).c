#include <stdio.h>

int main(void)
{
    char small, cap = 'G';

    /*
    문자 상수는 4바이트 크기를 갖지만 아스키코드 값이 0~127 범위에 있으므로 2진수로 바꾸면
    왼쪽 3바이트는 모두 0이 되고, 오른쪽 1바이트만 의미를 갖는다. 1바이트는 8비트고,
    (8비트는 2^8이므로 256가지의 값을 표현할 수 있다)

    따라서 문자는 1바이트 크기의 char형 변수에 저장해서 사용할 수 있다.
    컴파일러는 문자에서 아스키코드 값을 갖는 오른쪽 1바이트만 변수에 저장하고 남는 바이트는 버린다.
    */

    if ((cap >= 'A') && (cap <= 'Z')) // 대문자 범위인 경우
    {
        printf("%d\n", ('a' - 'A'));
        small = cap + ('a' - 'A'); //  대/소문자의 차이를 더해 소문자로 변환
        // small = cap + 32; //이렇게 해도 결과는 같다
    }

    // '\n'를 %c로 출력하면 줄이 바뀐다. 제어문자는 형태가 없으므로 %c로 출력하면 제어기능이 수행된다.
    printf("대문자 : %c %c", cap, '\n');
    printf("소문자 : %c", small);

    return 0;
}

/*
결과:
32
대문자 : G
소문자 : g

프로그램에서 문자를 사용할 때는 항상 양쪽에 작은따옴표를 붙인다.
컴파일러는 'a'를 문자 상수로 해석한다. 그러나 이런 문자 표현법은 컴파일 이후에는 약속된'정수'값인
아스키 코드 값으로 바뀌기 때문에 의미가 없다.

예를 들어 문자 상수 'a'는 정수값 97로 바뀐다.
결국 문자는 메모리에 저장되는 방식이 정수와 같다. 따라서 int형 변수에 저장하고 정수처럼 연산할 수 있다.
'a'를 %d로 출력하면 97이고, 정수 97을 %c로 출력하면 아스키코드 값이97인 문자를 출력한다.
결론적으로 문자 상수 'a'와 97은 같은 데이터이며 변환 문자열의 종류에 따라 출력형태가 결정된다.


#   아스키 코드
:
아스키 코드는 128개의 문자를 0~127의 숫자 중에 각각 어떤 값으로 표현할지 정의한 것이다.

        종류        /      문자 상수      /    아스키 코드 값     /    출력 시
    ------------------------------------------------------------------------------
    숫자 문자 (10개)/    '0' ~ '9'       /  48  ~   57          /   문자 출력
    대문자(26개)    /   'A' ~ 'B'        /  65  ~   90          /   문자 출력
    소문자(26개)    /   'a' ~ 'z'        /  97  ~   122         /   문자 출력
    특수문자(33개)  /   'a' ~ 'z'        /  32, 36, 38 ...      /   문자 출력
    제어문자(33개)  /'\0', '\t', '\n'... /  0, 9, 10, 13 ...    /   제어 기능 수행
    ------------------------------------------------------------------------------

    - 알파벳과 숫자는 각각 연속된 아스키 코드 값을 갖는다.
    - 소문자가 대문자보다 아스키 코드 값이 크다.
    - 제어 문자는 백슬래시와 함께 표시하며 출력할 때 그 기능을 수행한다.





*/